"use strict";(self.webpackChunkreact_native_testing_library_website=self.webpackChunkreact_native_testing_library_website||[]).push([[671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=o,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3901:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294),o=n(3743);const r={tableOfContentsInline:"tableOfContentsInline_prmo"};function i(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:i}=e;return a.createElement("div",{className:r.tableOfContentsInline},a.createElement(o.Z,{toc:t,minHeadingLevel:n,maxHeadingLevel:i,className:"table-of-contents",linkClassName:null}))}},3743:(e,t,n)=>{n.d(t,{Z:()=>h});var a=n(7462),o=n(7294),r=n(6668);function i(e){const t=e.map((e=>({...e,parentIndex:-1,children:[]}))),n=Array(7).fill(-1);t.forEach(((e,t)=>{const a=n.slice(2,e.level);e.parentIndex=Math.max(...a),n[e.level]=t}));const a=[];return t.forEach((e=>{const{parentIndex:n,...o}=e;n>=0?t[n].children.push(o):a.push(o)})),a}function s(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:a}=e;return t.flatMap((e=>{const t=s({toc:e.children,minHeadingLevel:n,maxHeadingLevel:a});return function(e){return e.level>=n&&e.level<=a}(e)?[{...e,children:t}]:t}))}function l(e){const t=e.getBoundingClientRect();return t.top===t.bottom?l(e.parentNode):t}function c(e,t){var n;let{anchorTopOffset:a}=t;const o=e.find((e=>l(e).top>=a));if(o){var r;return function(e){return e.top>0&&e.bottom<window.innerHeight/2}(l(o))?o:null!=(r=e[e.indexOf(o)-1])?r:null}return null!=(n=e[e.length-1])?n:null}function p(){const e=(0,o.useRef)(0),{navbar:{hideOnScroll:t}}=(0,r.L)();return(0,o.useEffect)((()=>{e.current=t?0:document.querySelector(".navbar").clientHeight}),[t]),e}function d(e){const t=(0,o.useRef)(void 0),n=p();(0,o.useEffect)((()=>{if(!e)return()=>{};const{linkClassName:a,linkActiveClassName:o,minHeadingLevel:r,maxHeadingLevel:i}=e;function s(){const e=function(e){return Array.from(document.getElementsByClassName(e))}(a),s=function(e){let{minHeadingLevel:t,maxHeadingLevel:n}=e;const a=[];for(let o=t;o<=n;o+=1)a.push("h"+o+".anchor");return Array.from(document.querySelectorAll(a.join()))}({minHeadingLevel:r,maxHeadingLevel:i}),l=c(s,{anchorTopOffset:n.current}),p=e.find((e=>l&&l.id===function(e){return decodeURIComponent(e.href.substring(e.href.indexOf("#")+1))}(e)));e.forEach((e=>{!function(e,n){n?(t.current&&t.current!==e&&t.current.classList.remove(o),e.classList.add(o),t.current=e):e.classList.remove(o)}(e,e===p)}))}return document.addEventListener("scroll",s),document.addEventListener("resize",s),s(),()=>{document.removeEventListener("scroll",s),document.removeEventListener("resize",s)}}),[e,n])}function m(e){let{toc:t,className:n,linkClassName:a,isChild:r}=e;return t.length?o.createElement("ul",{className:r?void 0:n},t.map((e=>o.createElement("li",{key:e.id},o.createElement("a",{href:"#"+e.id,className:null!=a?a:void 0,dangerouslySetInnerHTML:{__html:e.value}}),o.createElement(m,{isChild:!0,toc:e.children,className:n,linkClassName:a}))))):null}const u=o.memo(m);function h(e){let{toc:t,className:n="table-of-contents table-of-contents__left-border",linkClassName:l="table-of-contents__link",linkActiveClassName:c,minHeadingLevel:p,maxHeadingLevel:m,...h}=e;const g=(0,r.L)(),f=null!=p?p:g.tableOfContents.minHeadingLevel,v=null!=m?m:g.tableOfContents.maxHeadingLevel,k=function(e){let{toc:t,minHeadingLevel:n,maxHeadingLevel:a}=e;return(0,o.useMemo)((()=>s({toc:i(t),minHeadingLevel:n,maxHeadingLevel:a})),[t,n,a])}({toc:t,minHeadingLevel:f,maxHeadingLevel:v});return d((0,o.useMemo)((()=>{if(l&&c)return{linkClassName:l,linkActiveClassName:c,minHeadingLevel:f,maxHeadingLevel:v}}),[l,c,f,v])),o.createElement(u,(0,a.Z)({toc:k,className:n,linkClassName:l},h))}},7977:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),o=(n(7294),n(3905)),r=n(3901);const i={id:"testing-env",title:"Testing Environment"},s=void 0,l={unversionedId:"testing-env",id:"testing-env",title:"Testing Environment",description:"This document is intended for more advanced audience. You should be able to write integration or component tests without reading this.",source:"@site/docs/TestingEnvironment.md",sourceDirName:".",slug:"/testing-env",permalink:"/react-native-testing-library/docs/testing-env",draft:!1,editUrl:"https://github.com/callstack/react-native-testing-library/blob/main/website/docs/TestingEnvironment.md",tags:[],version:"current",frontMatter:{id:"testing-env",title:"Testing Environment"},sidebar:"docs",previous:{title:"Troubleshooting",permalink:"/react-native-testing-library/docs/troubleshooting"},next:{title:"Understanding Act function",permalink:"/react-native-testing-library/docs/understanding-act"}},c={},p=[{value:"React renderers",id:"react-renderers",level:2},{value:"React Test Renderer",id:"react-test-renderer",level:2},{value:"Element tree",id:"element-tree",level:2},{value:"Host and composite components",id:"host-and-composite-components",level:2},{value:"Differentiating between host and composite elements",id:"differentiating-between-host-and-composite-elements",level:3},{value:"Tree nodes",id:"tree-nodes",level:2},{value:"Asserting props",id:"asserting-props",level:3},{value:"Tree navigation",id:"tree-navigation",level:2},{value:"Queries",id:"queries",level:2}],d={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"This document is intended for more advanced audience. You should be able to write integration or component tests without reading this.\nIt is intended for people who want to better understand internals of our testing environment, e.g. in order to contribute to the codebase.")),(0,o.kt)("p",null,"React Native Testing Library allows you to write integration and component tests for your React Native app or library. While the JSX code used in tests closely resembles your React Native app, the things are not quite as simple as they might appear. In this document we will describe the key elements of our testing environment and highlight things to be aware of when writing more advanced tests or diagnosing issues."),(0,o.kt)(r.Z,{toc:p,mdxType:"TOCInline"}),(0,o.kt)("h2",{id:"react-renderers"},"React renderers"),(0,o.kt)("p",null,"React allows you to write declarative code using JSX, write function or class components, or use hooks like ",(0,o.kt)("inlineCode",{parentName:"p"},"useState"),". In order to output the results of your components it needs to work with a renderer. Every React app uses some type of renderer: React Native is a renderer for mobile apps, web apps use React DOM, and there are other more ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/chentsulin/awesome-react-renderer"},"specialised renderers")," that can e.g. render to console or HTML canvas."),(0,o.kt)("p",null,"When you run your tests in React Native Testing Library, somewhat contrary to what the name suggest, they are actually ",(0,o.kt)("strong",{parentName:"p"},"not")," using React Native renderer. This is because this renderer needs to be run on iOS or Android operating system, so it would need to run on device or simulator."),(0,o.kt)("h2",{id:"react-test-renderer"},"React Test Renderer"),(0,o.kt)("p",null,"Instead, RNTL uses React Test Renderer which is a specialised renderer that allows rendering to pure JavaScript objects without access to mobile OS, and that can run in a Node.js environment using Jest (or any other JavaScript test runner)."),(0,o.kt)("p",null,"Using React Test Renderer has pros and cons."),(0,o.kt)("p",null,"Benefits:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"tests can run on most CIs (linux, etc) and do not require a mobile device or emulator"),(0,o.kt)("li",{parentName:"ul"},"faster test execution"),(0,o.kt)("li",{parentName:"ul"},"light runtime environment")),(0,o.kt)("p",null,"Disadvantages:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Tests do not execute native code"),(0,o.kt)("li",{parentName:"ul"},"Tests are not aware of view state that would be managed by native components, e.g. focus, unmanaged text boxes, etc."),(0,o.kt)("li",{parentName:"ul"},"Assertions do not operate on native view hierarchy"),(0,o.kt)("li",{parentName:"ul"},"Runtime behaviours are simulated, sometimes imperfectly")),(0,o.kt)("p",null,"It\u2019s worth noting that React Testing Library (web one), works a bit different. While RTL also runs in Jest, it also has access to simulated browser DOM environment from jsdom package, so it can use a regular React DOM renderer. Unfortunately, there is no similar React Native runtime environment package. This is probably due to to the fact that while browser environment is well defined and highly standardised, the React Native environment is in constant evolution, in sync with the evolution of underlying OS-es. Maintaining such environment would require duplicating countless React Native behaviours, and keeping that in sync as React Native evolves."),(0,o.kt)("h2",{id:"element-tree"},"Element tree"),(0,o.kt)("p",null,"Invoking ",(0,o.kt)("inlineCode",{parentName:"p"},"render()")," function results in creation of an element tree. This is done internally by invoking ",(0,o.kt)("inlineCode",{parentName:"p"},"TestRenderer.create()")," method. The output tree represents your React Native component tree, each node of that tree is an \u201cinstance\u201d of some React component (to be more precise: each node represents a React fiber, and only class components have instances, while function components store the hook state using fiber)."),(0,o.kt)("p",null,"These tree elements are represented by ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactTestInstance")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"interface ReactTestInstance {\n  type: ElementType;\n  props: { [propName: string]: any };\n  parent: ReactTestInstance | null;\n  children: Array<ReactTestInstance | string>;\n\n  // Other props and methods\n}\n")),(0,o.kt)("p",null,"Based on: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react-test-renderer/index.d.ts"},"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react-test-renderer/index.d.ts")),(0,o.kt)("h2",{id:"host-and-composite-components"},"Host and composite components"),(0,o.kt)("p",null,"One of the most important aspects of the element tree is that it is composed of both host and composite components:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://reactnative.dev/architecture/glossary#react-host-components-or-host-components"},"Host components")," are components that will have direct counterparts in the native view tree. Typical examples are ",(0,o.kt)("inlineCode",{parentName:"li"},"<View>"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"<Text>")," , ",(0,o.kt)("inlineCode",{parentName:"li"},"<TextInput>"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"<Image>")," from React Native. You can think of these as analogue of ",(0,o.kt)("inlineCode",{parentName:"li"},"<div>"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"<span>")," etc on the Web. You can also create your own host views as native modules or import them from 3rd party libraries, like React Navigation or React Native Gesture Handler."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://reactnative.dev/architecture/glossary#react-composite-components"},"Composite components")," are React code organisation units that exist only on the JavaScript side of your app. Typical examples are components you create (both function and class components), components imported from React Native (",(0,o.kt)("inlineCode",{parentName:"li"},"View"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"Text"),", etc) or from 3rd party packages.")),(0,o.kt)("p",null,"That might sound a bit confusing at first, since we put React Native\u2019s ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," in both categories. There are actually two ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," components: composite one and host one. The relation between them is as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"composite ",(0,o.kt)("inlineCode",{parentName:"li"},"View")," is the type imported from ",(0,o.kt)("inlineCode",{parentName:"li"},"react-native")," package. It\u2019s a JavaScript component, which renders host ",(0,o.kt)("inlineCode",{parentName:"li"},"View")," as its only child in the element tree."),(0,o.kt)("li",{parentName:"ul"},"host ",(0,o.kt)("inlineCode",{parentName:"li"},"View")," , which you do not render directly. React Native takes the props you pass to the composite ",(0,o.kt)("inlineCode",{parentName:"li"},"View"),", does some processing on them and passes them to host ",(0,o.kt)("inlineCode",{parentName:"li"},"View"),".")),(0,o.kt)("p",null,"The part of the tree looks as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"* <View> (composite)\n  * <View> (host)\n    * children prop passed in JSX\n")),(0,o.kt)("p",null,"Similar relation exists between other composite and host pairs: e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"Text")," , ",(0,o.kt)("inlineCode",{parentName:"p"},"TextInput")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Image")," components:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"* <Text> (composite)\n  * <Text> (host)\n    * string (or mixed) content\n")),(0,o.kt)("p",null,"Not all React Native components are organised this way, e.g. when you use ",(0,o.kt)("inlineCode",{parentName:"p"},"Pressable")," (or ",(0,o.kt)("inlineCode",{parentName:"p"},"TouchableOpacity"),") there is no host ",(0,o.kt)("inlineCode",{parentName:"p"},"Pressable"),", but composite ",(0,o.kt)("inlineCode",{parentName:"p"},"Pressable")," is rendering a host ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," with certain props being set:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"* <Pressable> (composite)\n  * <View accessible={true} {...}> (host)\n    * children prop passed in JSX\n")),(0,o.kt)("h3",{id:"differentiating-between-host-and-composite-elements"},"Differentiating between host and composite elements"),(0,o.kt)("p",null,"Any easy way to differentiate between host and composite elements is the ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," prop of ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactTestInstance"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"for host components it\u2019s always a string value representing component name, e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},'"View"')),(0,o.kt)("li",{parentName:"ul"},"for composite components it\u2019s a function or class corresponding to the component")),(0,o.kt)("p",null,"You can use the following code to check if given element is a host one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function isHostElement(element: ReactTestInstance) {\n  return typeof element.type === 'string';\n}\n")),(0,o.kt)("h2",{id:"tree-nodes"},"Tree nodes"),(0,o.kt)("p",null,"We encourage you to only assert values on host views in your tests, because they represent the user interface view and controls that the user will be able to see and interact with. Users cannot see, or interact with, composite views as they exist purely in JavaScript domain and do not generate any visible UI."),(0,o.kt)("h3",{id:"asserting-props"},"Asserting props"),(0,o.kt)("p",null,"As an example, if you make assertions on a ",(0,o.kt)("inlineCode",{parentName:"p"},"style")," prop of a composite element, there is no guarantee that the style will be visible to the user, as the component author can forget to pass this prop to some underlying ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," or other host component. Similarly ",(0,o.kt)("inlineCode",{parentName:"p"},"onPress")," event handler on a composite prop can be unreachable by the user."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function ForgotToPassPropsButton({ title, onPress, style }) {\n  return (\n    <Pressable>\n      <Text>{title}</Text>\n    </Pressable>\n  );\n}\n")),(0,o.kt)("p",null,"In the above example user defined components accepts both ",(0,o.kt)("inlineCode",{parentName:"p"},"onPress")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"style")," props but does not pass it (through ",(0,o.kt)("inlineCode",{parentName:"p"},"Pressable"),") to host views, so these props will not affect the user interface. Additionally, React Native and other libraries might pass some of the props under different names or transform their values between composite and host components."),(0,o.kt)("h2",{id:"tree-navigation"},"Tree navigation"),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"You should avoid navigating over element tree, as this makes your testing code fragile and may result in false positives. This section is more relevant for people how want to contribute to our codebase.")),(0,o.kt)("p",null,"When navigating a tree of react elements using ",(0,o.kt)("inlineCode",{parentName:"p"},"parent")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"children")," props of a ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactTestInstance")," element, you will encounter both host and composite elements. You should be careful when navigating the element tree, as the tree structure for 3rd party components and change independently from your code and cause unexpected test failures."),(0,o.kt)("p",null,"Inside RNTL we have various tree navigation helpers: ",(0,o.kt)("inlineCode",{parentName:"p"},"getHostParent"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"getHostChildren"),", etc. These are intentionally not exported as using them is not a recommended practice."),(0,o.kt)("h2",{id:"queries"},"Queries"),(0,o.kt)("p",null,"Most of the Testing Library queries return host components, in order to encourage best practices described above."),(0,o.kt)("p",null,"At this stage, there are some noteworthy exceptions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"*ByText")," queries returns composite ",(0,o.kt)("inlineCode",{parentName:"li"},"Text")," element"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"*ByDisplayValue")," queries returns composite ",(0,o.kt)("inlineCode",{parentName:"li"},"TextInput")," element"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"*ByPlaceholderText")," queries returns composite ",(0,o.kt)("inlineCode",{parentName:"li"},"TextInput")," element")),(0,o.kt)("p",null,"This will change in the near future, as we make efforts for all queries to return host components. Meanwhile it shouldn't be a huge issue, as composite ",(0,o.kt)("inlineCode",{parentName:"p"},"Text")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"TextInput"),"generally pass their props down to host counterparts."),(0,o.kt)("p",null,"Additionally, ",(0,o.kt)("inlineCode",{parentName:"p"},"UNSAFE_*ByType")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"UNSAFE_*ByProps")," queries can return both host and composite components depending on used predicates. They are marked as unsafe precisely because testing composite components makes your test more fragile."))}u.isMDXComponent=!0}}]);