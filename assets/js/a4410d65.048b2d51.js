"use strict";(self.webpackChunkreact_native_testing_library_website=self.webpackChunkreact_native_testing_library_website||[]).push([[968],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(n),h=l,u=d["".concat(s,".").concat(h)]||d[h]||m[h]||o;return n?a.createElement(u,i(i({ref:t},p),{},{components:n})):a.createElement(u,i({ref:t},p))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=n.length,i=new Array(o);i[0]=h;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[d]="string"==typeof e?e:l,i[1]=r;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4909:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return d}});var a=n(7462),l=n(3366),o=(n(7294),n(3905)),i=["components"],r={id:"jest-matchers",title:"Jest Matchers"},s="Element Existence",c={unversionedId:"jest-matchers",id:"jest-matchers",title:"Jest Matchers",description:"toBeOnTheScreen()",source:"@site/docs/JestMatchers.md",sourceDirName:".",slug:"/jest-matchers",permalink:"/react-native-testing-library/docs/jest-matchers",draft:!1,editUrl:"https://github.com/callstack/react-native-testing-library/blob/main/website/docs/JestMatchers.md",tags:[],version:"current",frontMatter:{id:"jest-matchers",title:"Jest Matchers"}},p={},d=[{value:"<code>toBeOnTheScreen()</code>",id:"tobeonthescreen",level:2},{value:"<code>toHaveTextContent()</code>",id:"tohavetextcontent",level:2},{value:"<code>toHaveDisplayValue()</code>",id:"tohavedisplayvalue",level:2},{value:"<code>toHaveAccessibleValue()</code>",id:"tohaveaccessiblevalue",level:2},{value:"<code>toBeEnabled()</code> / <code>toBeDisabled</code>",id:"tobeenabled--tobedisabled",level:2},{value:"<code>toBeSelected()</code>",id:"tobeselected",level:2},{value:"<code>toBeChecked()</code> / <code>toBePartiallyChecked()</code>",id:"tobechecked--tobepartiallychecked",level:2},{value:"<code>toBeExpanded()</code> /  <code>toBeCollapsed()</code>",id:"tobeexpanded---tobecollapsed",level:2},{value:"<code>toBeBusy()</code>",id:"tobebusy",level:2},{value:"<code>toBeVisible()</code>",id:"tobevisible",level:2},{value:"<code>toHaveStyle()</code>",id:"tohavestyle",level:2},{value:"<code>toBeEmptyElement()</code>",id:"tobeemptyelement",level:2},{value:"<code>toContainElement()</code>",id:"tocontainelement",level:2},{value:"<code>toHaveProp()</code>",id:"tohaveprop",level:2}],m={toc:d},h="wrapper";function u(e){var t=e.components,n=(0,l.Z)(e,i);return(0,o.kt)(h,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"element-existence"},"Element Existence"),(0,o.kt)("h2",{id:"tobeonthescreen"},(0,o.kt)("inlineCode",{parentName:"h2"},"toBeOnTheScreen()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toBeOnTheScreen()\n")),(0,o.kt)("p",null,"This allows you to assert whether element is in the element tree or not."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"This matchers requires element to be attached to the element tree. This might be useful if your holding a reference to an element and the element gets unmounted during the test.")),(0,o.kt)("h1",{id:"element-state"},"Element State"),(0,o.kt)("h2",{id:"tohavetextcontent"},(0,o.kt)("inlineCode",{parentName:"h2"},"toHaveTextContent()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toHaveTextContent(text: TextMatch, options?: TextMatchOptions)\n")),(0,o.kt)("p",null,"This allows you to assert whether the given element has a text content or not. It accepts either ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"RegExp")," matchers, as well as ",(0,o.kt)("inlineCode",{parentName:"p"},"TextMatchOptions"),"."),(0,o.kt)("p",null,"When ",(0,o.kt)("inlineCode",{parentName:"p"},"text")," parameter is ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," it will only check for existence of text content, and when ",(0,o.kt)("inlineCode",{parentName:"p"},"text")," is defined it will check if the actual text content matches passed value."),(0,o.kt)("h2",{id:"tohavedisplayvalue"},(0,o.kt)("inlineCode",{parentName:"h2"},"toHaveDisplayValue()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toHaveDisplayValue(value: TextMatch, options?: TextMatchOptions)\n")),(0,o.kt)("p",null,"This allows you to assert whether the given ",(0,o.kt)("inlineCode",{parentName:"p"},"TextInput")," element has specified display value. It accepts either ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"RegExp")," matchers, as well as ",(0,o.kt)("inlineCode",{parentName:"p"},"TextMatchOptions"),"."),(0,o.kt)("h2",{id:"tohaveaccessiblevalue"},(0,o.kt)("inlineCode",{parentName:"h2"},"toHaveAccessibleValue()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toHaveAccessibleValue(...)\n")),(0,o.kt)("p",null,"This allows you to assert whether the given element has specified accessible value."),(0,o.kt)("h2",{id:"tobeenabled--tobedisabled"},(0,o.kt)("inlineCode",{parentName:"h2"},"toBeEnabled()")," / ",(0,o.kt)("inlineCode",{parentName:"h2"},"toBeDisabled")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toBeEnabled()\nexpect(element).toBeDisabled()\n")),(0,o.kt)("p",null,"These allows you to assert whether the given element is enabled or disabled from user's perspective. It relies on accessibility disabled state as set by ",(0,o.kt)("inlineCode",{parentName:"p"},"aria-disabled")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibilityState.disabled")," props. It will considers given element disabled when it or any of its ancestors is disabled."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"This matchers are direct negation of each other, and both are probivided to avoid double negations in your assertions.")),(0,o.kt)("h2",{id:"tobeselected"},(0,o.kt)("inlineCode",{parentName:"h2"},"toBeSelected()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toBeSelected()\n")),(0,o.kt)("p",null,"This allows you to assert whether the given element is selected from user's perspective. It relies on accessibility selected state as set by ",(0,o.kt)("inlineCode",{parentName:"p"},"aria-selected")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibilityState.selected")," props."),(0,o.kt)("h2",{id:"tobechecked--tobepartiallychecked"},(0,o.kt)("inlineCode",{parentName:"h2"},"toBeChecked()")," / ",(0,o.kt)("inlineCode",{parentName:"h2"},"toBePartiallyChecked()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toBeChecked()\nexpect(element).toBePartiallyChecked()\n")),(0,o.kt)("p",null,"These allows you to assert whether the given element is checked or partially checked from user's perspective. It relies on accessibility checked state as set by ",(0,o.kt)("inlineCode",{parentName:"p"},"aria-checked")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibilityState.checked")," props."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"toBeChecked()")," matcher works only on elements with ",(0,o.kt)("inlineCode",{parentName:"li"},"checkbox")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"radio")," role."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"toBePartiallyChecked()")," matchers works only on elements with ",(0,o.kt)("inlineCode",{parentName:"li"},"checkbox")," role."))),(0,o.kt)("h2",{id:"tobeexpanded---tobecollapsed"},(0,o.kt)("inlineCode",{parentName:"h2"},"toBeExpanded()")," /  ",(0,o.kt)("inlineCode",{parentName:"h2"},"toBeCollapsed()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toBeExpanded()\nexpect(element).toBeCollapsed()\n")),(0,o.kt)("p",null,"These allows you to assert whether the given element is expanded or collapsed from user's perspective. It relies on accessibility disabled state as set by ",(0,o.kt)("inlineCode",{parentName:"p"},"aria-expanded")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibilityState.expanded")," props."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"This matchers are direct negation of each other for expandable elements (elements with explicit ",(0,o.kt)("inlineCode",{parentName:"p"},"aria-expanded")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibilityState.expanded")," props). However, both with fail for non-expandable elements (ones without explicit ",(0,o.kt)("inlineCode",{parentName:"p"},"aria-expanded")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibilityState.expanded")," props).")),(0,o.kt)("h2",{id:"tobebusy"},(0,o.kt)("inlineCode",{parentName:"h2"},"toBeBusy()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toBeBusy()\n")),(0,o.kt)("p",null,"This allows you to assert whether the given element is busy from user's perspective. It relies on accessibility selected state as set by ",(0,o.kt)("inlineCode",{parentName:"p"},"aria-busy")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibilityState.busy")," props."),(0,o.kt)("h1",{id:"element-styles"},"Element Styles"),(0,o.kt)("h2",{id:"tobevisible"},(0,o.kt)("inlineCode",{parentName:"h2"},"toBeVisible()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toBeVisible()\n")),(0,o.kt)("p",null,"This allows you to assert whether the given element is visible from user's perspective. "),(0,o.kt)("p",null,"The element is considered invisibile when it or any of its ancestors has ",(0,o.kt)("inlineCode",{parentName:"p"},"display: none")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"opacity: 0")," styles, as well as when it's hidden from accessbility."),(0,o.kt)("h2",{id:"tohavestyle"},(0,o.kt)("inlineCode",{parentName:"h2"},"toHaveStyle()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toHaveStyle(style: StyleProp<Style>)\n")),(0,o.kt)("p",null,"This allows you to assert whether the given element has given styles. "),(0,o.kt)("h1",{id:"other"},"Other"),(0,o.kt)("h2",{id:"tobeemptyelement"},(0,o.kt)("inlineCode",{parentName:"h2"},"toBeEmptyElement()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toBeEmptyElement()\n")),(0,o.kt)("p",null,"This allows you to assert whether the given element does not have any host child elements nor text content."),(0,o.kt)("h2",{id:"tocontainelement"},(0,o.kt)("inlineCode",{parentName:"h2"},"toContainElement()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(container).toContainElement(element: ReactTestInstance | null)\n")),(0,o.kt)("p",null,"This allows you to assert whether the given container element does contain another host element."),(0,o.kt)("h2",{id:"tohaveprop"},(0,o.kt)("inlineCode",{parentName:"h2"},"toHaveProp()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"expect(element).toHaveProp(name: string, value?: unknown)\n")),(0,o.kt)("p",null,"This allows you to assert whether the given element has a given prop. When ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," parameter is ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," it will only check for existence of prop, and when ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," is defined it will check if the actual value matches passed value."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"This matchers should be treated as escape hatch to be used when all other matchers are not suitable.")))}u.isMDXComponent=!0}}]);