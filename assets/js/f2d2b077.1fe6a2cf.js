"use strict";(self.webpackChunkreact_native_testing_library_website=self.webpackChunkreact_native_testing_library_website||[]).push([[154],{8733:(e,i,s)=>{s.r(i),s.d(i,{assets:()=>d,contentTitle:()=>l,default:()=>a,frontMatter:()=>n,metadata:()=>c,toc:()=>h});var t=s(5893),r=s(1151);const n={id:"how-should-i-query",title:"How Should I Query?"},l=void 0,c={id:"how-should-i-query",title:"How Should I Query?",description:"React Native Testing Library provides various query types, allowing great flexibility in finding views appropriate for your tests. At the same time, the number of queries might be confusing. This guide aims to help you pick the correct queries for your test scenarios.",source:"@site/docs/HowShouldIQuery.md",sourceDirName:".",slug:"/how-should-i-query",permalink:"/react-native-testing-library/docs/how-should-i-query",draft:!1,unlisted:!1,editUrl:"https://github.com/callstack/react-native-testing-library/blob/main/website/docs/HowShouldIQuery.md",tags:[],version:"current",frontMatter:{id:"how-should-i-query",title:"How Should I Query?"},sidebar:"docs",previous:{title:"Jest Matchers",permalink:"/react-native-testing-library/docs/jest-matchers"},next:{title:"Troubleshooting",permalink:"/react-native-testing-library/docs/troubleshooting"}},d={},h=[{value:"Query parts",id:"query-parts",level:2},{value:"Query variant",id:"query-variant",level:2},{value:"Idiomatic query variants",id:"idiomatic-query-variants",level:3},{value:"Query predicate",id:"query-predicate",level:2},{value:"Idiomatic query predicates",id:"idiomatic-query-predicates",level:3},{value:"1. By Role query",id:"by-role-query",level:3},{value:"Name option",id:"by-role-query-name-option",level:4},{value:"2. Text input queries",id:"text-input-queries",level:3},{value:"3. Other accessible queries",id:"other-accessible-queries",level:3},{value:"4. Test ID query",id:"test-id-query",level:3}];function o(e){const i={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"React Native Testing Library provides various query types, allowing great flexibility in finding views appropriate for your tests. At the same time, the number of queries might be confusing. This guide aims to help you pick the correct queries for your test scenarios."}),"\n",(0,t.jsx)(i.h2,{id:"query-parts",children:"Query parts"}),"\n",(0,t.jsxs)(i.p,{children:["Each query is composed of two parts: variant and predicate, which are separated by the ",(0,t.jsx)(i.code,{children:"by"})," word in the middle of the query."]}),"\n",(0,t.jsx)(i.p,{children:"Consider the following query:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"getByRole()\n"})}),"\n",(0,t.jsxs)(i.p,{children:["For this query, ",(0,t.jsx)(i.code,{children:"getBy*"})," is the query variant, and ",(0,t.jsx)(i.code,{children:"*ByRole"})," is the predicate."]}),"\n",(0,t.jsx)(i.h2,{id:"query-variant",children:"Query variant"}),"\n",(0,t.jsx)(i.p,{children:"The query variants describe the expected number (and timing) of matching elements, so they differ in their return type."}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Variant"}),(0,t.jsx)(i.th,{children:"Assertion"}),(0,t.jsx)(i.th,{children:"Return type"}),(0,t.jsx)(i.th,{children:"Is Async?"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#get-by",children:(0,t.jsx)(i.code,{children:"getBy*"})})}),(0,t.jsx)(i.td,{children:"Exactly one matching element"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"ReactTestInstance"})}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#get-all-by",children:(0,t.jsx)(i.code,{children:"getAllBy*"})})}),(0,t.jsx)(i.td,{children:"At least one matching element"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"Array<ReactTestInstance>"})}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#query-by",children:(0,t.jsx)(i.code,{children:"queryBy*"})})}),(0,t.jsx)(i.td,{children:"Zero or one matching element"}),(0,t.jsx)(i.td,{children:(0,t.jsx)("code",{children:"ReactTestInstance | null"})}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#query-all-by",children:(0,t.jsx)(i.code,{children:"queryAllBy*"})})}),(0,t.jsx)(i.td,{children:"No assertion"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"Array<ReactTestInstance>"})}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#find-by",children:(0,t.jsx)(i.code,{children:"findBy*"})})}),(0,t.jsx)(i.td,{children:"Exactly one matching element"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"Promise<ReactTestInstance>"})}),(0,t.jsx)(i.td,{children:"Yes"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#find-all-by",children:(0,t.jsx)(i.code,{children:"findAllBy*"})})}),(0,t.jsx)(i.td,{children:"At least one matching element"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"Promise<Array<ReactTestInstance>>"})}),(0,t.jsx)(i.td,{children:"Yes"})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"Queries work as implicit assertions on the number of matching elements and will throw an error when the assertion fails."}),"\n",(0,t.jsx)(i.h3,{id:"idiomatic-query-variants",children:"Idiomatic query variants"}),"\n",(0,t.jsx)(i.p,{children:"Idiomatic query variants clarify test intent and the expected number of matching elements. They will also throw helpful errors if assertions fail to help diagnose the issues."}),"\n",(0,t.jsx)(i.p,{children:"Here are general guidelines for picking idiomatic query variants:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"getBy*"})," in the most common case when you expect a ",(0,t.jsx)(i.strong,{children:"single matching element"}),". Use other queries only in more specific cases."]}),"\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"findBy*"})," when an element is not yet in the element tree, but you expect it to be there as a ",(0,t.jsx)(i.strong,{children:"result of some asynchronous action"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"getAllBy*"})," (and ",(0,t.jsx)(i.code,{children:"findAllBy*"})," for async) if you expect ",(0,t.jsx)(i.strong,{children:"more than one matching element"}),", e.g. in a list."]}),"\n",(0,t.jsxs)(i.li,{children:["Use ",(0,t.jsx)(i.code,{children:"queryBy*"})," only when element ",(0,t.jsx)(i.strong,{children:"should not exist"})," to use it together with e.g. ",(0,t.jsx)(i.a,{href:"jest-matchers#tobeonthescreen",children:(0,t.jsx)(i.code,{children:"not.toBeOnTheScreen()"})})," matcher."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Avoid using ",(0,t.jsx)(i.code,{children:"queryAllBy*"})," in regular tests, as it provides no assertions on the number of matching elements. You may still find it useful when building reusable custom testing tools."]}),"\n",(0,t.jsx)(i.h2,{id:"query-predicate",children:"Query predicate"}),"\n",(0,t.jsx)(i.p,{children:"The query predicate describes how you decide whether to match the given element."}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Predicate"}),(0,t.jsx)(i.th,{children:"Supported elements"}),(0,t.jsx)(i.th,{children:"Inspected props"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#by-role",children:(0,t.jsx)(i.code,{children:"*ByRole"})})}),(0,t.jsx)(i.td,{children:"all host elements"}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.code,{children:"role"}),", ",(0,t.jsx)(i.code,{children:"accessibilityRole"}),",",(0,t.jsx)("br",{})," optional: accessible name, accessibility state and value"]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#by-label-text",children:(0,t.jsx)(i.code,{children:"*ByLabelText"})})}),(0,t.jsx)(i.td,{children:"all host elements"}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.code,{children:"aria-label"}),", ",(0,t.jsx)(i.code,{children:"aria-labelledby"}),",",(0,t.jsx)("br",{})," ",(0,t.jsx)(i.code,{children:"accessibilityLabel"}),", ",(0,t.jsx)(i.code,{children:"accessibilityLabelledBy"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#by-display-value",children:(0,t.jsx)(i.code,{children:"*ByDisplayValue"})})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"TextInput"})}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.code,{children:"value"}),", ",(0,t.jsx)(i.code,{children:"defaultValue"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#by-placeholder-text",children:(0,t.jsx)(i.code,{children:"*ByPlaceholderText"})})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"TextInput"})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"placeholder"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#by-text",children:(0,t.jsx)(i.code,{children:"*ByText"})})}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"Text"})}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)(i.code,{children:"children"})," (text content)"]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#by-hint-text",children:(0,t.jsx)(i.code,{children:"*ByHintText"})})}),(0,t.jsx)(i.td,{children:"all host elements"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"accessibilityHint"})})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.a,{href:"api-queries#by-test-id",children:(0,t.jsx)(i.code,{children:"*ByTestId"})})}),(0,t.jsx)(i.td,{children:"all host elements"}),(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"testID"})})]})]})]}),"\n",(0,t.jsx)(i.h3,{id:"idiomatic-query-predicates",children:"Idiomatic query predicates"}),"\n",(0,t.jsxs)(i.p,{children:["Choosing the proper query predicate helps better express the test's intent and make the tests resemble how users interact with your code (components, screens, etc.) as much as possible following our ",(0,t.jsx)(i.a,{href:"https://testing-library.com/docs/guiding-principles",children:"Guiding Principles"}),". Additionally, most predicates promote the usage of proper accessibility props, which add a semantic layer on top of an element tree composed primarily of ",(0,t.jsx)(i.a,{href:"https://reactnative.dev/docs/view",children:(0,t.jsx)(i.code,{children:"View"})})," elements."]}),"\n",(0,t.jsx)(i.p,{children:"It is recommended to use query predicates in the following order of priority:"}),"\n",(0,t.jsx)(i.h3,{id:"by-role-query",children:"1. By Role query"}),"\n",(0,t.jsxs)(i.p,{children:["The first and most versatile predicate is ",(0,t.jsx)(i.a,{href:"api-queries#by-role",children:(0,t.jsx)(i.code,{children:"*ByRole"})}),", which starts with the semantic role of the element and can be further narrowed down with additional options. React Native has two role systems, the web/ARIA-compatible one based on ",(0,t.jsx)(i.a,{href:"https://reactnative.dev/docs/accessibility#role",children:(0,t.jsx)(i.code,{children:"role"})})," prop and the traditional one based on ",(0,t.jsx)(i.a,{href:"https://reactnative.dev/docs/accessibility#accessibilityrole",children:(0,t.jsx)(i.code,{children:"accessibilityRole"})})," prop, you can use either of these."]}),"\n",(0,t.jsx)(i.p,{children:"In most cases, you need to set accessibility roles explicitly (or your component library can set some of them for you). These roles allow assistive technologies (like screen readers) and testing code to understand your view hierarchy better."}),"\n",(0,t.jsx)(i.p,{children:"Some frequently used roles include:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"alert"})," - important text to be presented to the user, e.g., error message"]}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"button"})}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"checkbox"})," & ",(0,t.jsx)(i.code,{children:"switch"})," - on/off controls"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"heading"})," (",(0,t.jsx)(i.code,{children:"header"}),") - header for content section, e.g., the title of navigation bar"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"img"})," (",(0,t.jsx)(i.code,{children:"image"}),")"]}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"link"})}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"menu"})," & ",(0,t.jsx)(i.code,{children:"menuitem"})]}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"progressbar"})}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"radiogroup"})," & ",(0,t.jsx)(i.code,{children:"radio"})]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"searchbox"})," (",(0,t.jsx)(i.code,{children:"search"}),")"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"slider"})," (",(0,t.jsx)(i.code,{children:"adjustable"}),")"]}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"summary"})}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"tablist"})," & ",(0,t.jsx)(i.code,{children:"tab"})]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"text"})," - static text that cannot change"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"toolbar"})," - container for action buttons"]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"by-role-query-name-option",children:"Name option"}),"\n",(0,t.jsxs)(i.p,{children:["Frequently, you will want to add the ",(0,t.jsx)(i.a,{href:"api-queries#by-role-options",children:(0,t.jsx)(i.code,{children:"name"})})," option, which will match both the element's role and its accessible name (= element's accessibility label or text content)."]}),"\n",(0,t.jsx)(i.p,{children:"Here are a couple of examples:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["start button: ",(0,t.jsx)(i.code,{children:'getByRole("button", { name: "Start" })'})]}),"\n",(0,t.jsxs)(i.li,{children:["silent mode switch: ",(0,t.jsx)(i.code,{children:'getByRole("switch", { name: "Silent Mode" })'})]}),"\n",(0,t.jsxs)(i.li,{children:["screen header: ",(0,t.jsx)(i.code,{children:'getByRole("header", { name: "Settings" })'})]}),"\n",(0,t.jsxs)(i.li,{children:["undo menu item: ",(0,t.jsx)(i.code,{children:'getByRole("menuitem", { name: "Undo" })'})]}),"\n",(0,t.jsxs)(i.li,{children:["error messages: ",(0,t.jsx)(i.code,{children:'getByRole("alert", { name: /Not logged in/ })'})]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"text-input-queries",children:"2. Text input queries"}),"\n",(0,t.jsxs)(i.p,{children:["Querying ",(0,t.jsx)(i.a,{href:"https://reactnative.dev/docs/textinput",children:(0,t.jsx)(i.code,{children:"TextInput"})})," elements presents a unique challenge as there is no separate role for ",(0,t.jsx)(i.code,{children:"TextInput"})," elements. There is a ",(0,t.jsx)(i.code,{children:"searchbox"}),"/",(0,t.jsx)(i.code,{children:"search"})," role, which can be assigned to ",(0,t.jsx)(i.code,{children:"TextInput"}),", but it should be only used in the context of search inputs, leaving other text inputs without a role to query with."]}),"\n",(0,t.jsx)(i.p,{children:"Therefore, you can use the following queries to find relevant text inputs:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"api-queries#by-label-text",children:(0,t.jsx)(i.code,{children:"*ByLabelText"})})," - will match the accessibility label of the element. This query will match any host elements, including ",(0,t.jsx)(i.code,{children:"TextInput"})," elements."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"api-queries#by-placeholder-text",children:(0,t.jsx)(i.code,{children:"*ByPlaceholderText"})})," - will match the placeholder of ",(0,t.jsx)(i.code,{children:"TextInput"})," element. This query will match only ",(0,t.jsx)(i.code,{children:"TextInput"})," elements."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"api-queries#by-display-value",children:(0,t.jsx)(i.code,{children:"*ByDisplayValue"})})," - will the current (or default) value of ",(0,t.jsx)(i.code,{children:"TextInput"})," element. This query will match only ",(0,t.jsx)(i.code,{children:"TextInput"})," elements."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"other-accessible-queries",children:"3. Other accessible queries"}),"\n",(0,t.jsx)(i.p,{children:"These queries reflect the apps' user experience, both visual and through assistive technologies (e.g. screen reader)."}),"\n",(0,t.jsx)(i.p,{children:"These queries include:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"api-queries#by-text",children:(0,t.jsx)(i.code,{children:"*ByText"})})," - will match the text content of the element. This query will match only ",(0,t.jsx)(i.code,{children:"Text"})," elements."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"api-queries#by-label-text",children:(0,t.jsx)(i.code,{children:"*ByLabelText"})})," - will match the accessibility label of the element."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"api-queries#by-hint-text",children:(0,t.jsx)(i.code,{children:"*ByHintText"})})," - will match the accessibility hint of the element."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"test-id-query",children:"4. Test ID query"}),"\n",(0,t.jsxs)(i.p,{children:["As a final predicate, you can use the ",(0,t.jsx)(i.code,{children:"testID"})," prop to find relevant views. Using the ",(0,t.jsx)(i.a,{href:"api-queries#by-test-id",children:(0,t.jsx)(i.code,{children:"*ByTestId"})})," predicate offers the most flexibility, but at the same time, it does not represent the user experience, as users are not aware of test IDs."]}),"\n",(0,t.jsxs)(i.p,{children:["Note that using test IDs is a widespread technique in end-to-end testing due to various issues with querying views through other means ",(0,t.jsx)(i.strong,{children:"in its specific context"}),". Nevertheless, we still encourage you to use recommended RNTL queries as it will make your integration and component test more reliable and resilient."]})]})}function a(e={}){const{wrapper:i}={...(0,r.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},1151:(e,i,s)=>{s.d(i,{Z:()=>c,a:()=>l});var t=s(7294);const r={},n=t.createContext(r);function l(e){const i=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(n.Provider,{value:i},e.children)}}}]);