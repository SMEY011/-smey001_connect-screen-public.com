"use strict";(self.webpackChunkreact_native_testing_library_website=self.webpackChunkreact_native_testing_library_website||[]).push([[949],{4298:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=t(5893),o=t(1151);const s={id:"render-hook",title:"Render Hook API"},c=void 0,i={id:"render-hook",title:"Render Hook API",description:"Renders a test component that will call the provided callback, including any hooks it calls, every time it renders. Returns RenderHookResult object, which you can interact with.",source:"@site/docs/RenderHook.md",sourceDirName:".",slug:"/render-hook",permalink:"/react-native-testing-library/docs/render-hook",draft:!1,unlisted:!1,editUrl:"https://github.com/callstack/react-native-testing-library/blob/main/website/docs/RenderHook.md",tags:[],version:"current",frontMatter:{id:"render-hook",title:"Render Hook API"},sidebar:"docs",previous:{title:"Jest Matchers",permalink:"/react-native-testing-library/docs/jest-matchers"},next:{title:"Other APIs",permalink:"/react-native-testing-library/docs/other"}},d={},l=[{value:"<code>options</code>",id:"options",level:2},{value:"<code>initialProps</code>",id:"initialprops",level:3},{value:"<code>wrapper</code>",id:"wrapper",level:3},{value:"<code>RenderHookResult</code>",id:"renderhookresult",level:2},{value:"<code>result</code>",id:"result",level:3},{value:"<code>rerender</code>",id:"rerender",level:3},{value:"<code>unmount</code>",id:"unmount",level:3},{value:"Examples",id:"examples",level:2},{value:"With <code>initialProps</code>",id:"with-initialprops",level:3},{value:"With <code>wrapper</code>",id:"with-wrapper",level:3}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function renderHook<Result, Props>(\n  callback: (props?: Props) => Result,\n  options?: RenderHookOptions<Props>,\n): RenderHookResult<Result, Props>;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Renders a test component that will call the provided ",(0,r.jsx)(n.code,{children:"callback"}),", including any hooks it calls, every time it renders. Returns ",(0,r.jsx)(n.a,{href:"#renderhookresult",children:(0,r.jsx)(n.code,{children:"RenderHookResult"})})," object, which you can interact with."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { renderHook } from '@testing-library/react-native';\nimport { useCount } from '../useCount';\n\nit('should increment count', () => {\n  const { result } = renderHook(() => useCount());\n\n  expect(result.current.count).toBe(0);\n  act(() => {\n    // Note that you should wrap the calls to functions your hook returns with `act` if they trigger an update of your hook's state to ensure pending useEffects are run before your next assertion.\n    result.current.increment();\n  });\n  expect(result.current.count).toBe(1);\n});\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// useCount.js\nexport const useCount = () => {\n  const [count, setCount] = useState(0);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  return { count, increment };\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"renderHook"})," function accepts the following arguments:"]}),"\n",(0,r.jsxs)(n.p,{children:["Callback is a function that is called each ",(0,r.jsx)(n.code,{children:"render"})," of the test component. This function should call one or more hooks for testing."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"props"})," passed into the callback will be the ",(0,r.jsx)(n.code,{children:"initialProps"})," provided in the ",(0,r.jsx)(n.code,{children:"options"})," to ",(0,r.jsx)(n.code,{children:"renderHook"}),", unless new props are provided by a subsequent ",(0,r.jsx)(n.code,{children:"rerender"})," call."]}),"\n",(0,r.jsx)(n.h2,{id:"options",children:(0,r.jsx)(n.code,{children:"options"})}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"RenderHookOptions<Props>"})," object to modify the execution of the ",(0,r.jsx)(n.code,{children:"callback"})," function, containing the following properties:"]}),"\n",(0,r.jsx)(n.h3,{id:"initialprops",children:(0,r.jsx)(n.code,{children:"initialProps"})}),"\n",(0,r.jsxs)(n.p,{children:["The initial values to pass as ",(0,r.jsx)(n.code,{children:"props"})," to the ",(0,r.jsx)(n.code,{children:"callback"})," function of ",(0,r.jsx)(n.code,{children:"renderHook"}),". The ",(0,r.jsx)(n.code,{children:"Props"})," type is determined by the type passed to or inferred by the ",(0,r.jsx)(n.code,{children:"renderHook"})," call."]}),"\n",(0,r.jsx)(n.h3,{id:"wrapper",children:(0,r.jsx)(n.code,{children:"wrapper"})}),"\n",(0,r.jsxs)(n.p,{children:["A React component to wrap the test component in when rendering. This is usually used to add context providers from ",(0,r.jsx)(n.code,{children:"React.createContext"})," for the hook to access with ",(0,r.jsx)(n.code,{children:"useContext"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"renderhookresult",children:(0,r.jsx)(n.code,{children:"RenderHookResult"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface RenderHookResult<Result, Props> {\n  result: { current: Result };\n  rerender: (props: Props) => void;\n  unmount: () => void;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"renderHook"})," function returns an object that has the following properties:"]}),"\n",(0,r.jsx)(n.h3,{id:"result",children:(0,r.jsx)(n.code,{children:"result"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"current"})," value of the ",(0,r.jsx)(n.code,{children:"result"})," will reflect the latest of whatever is returned from the ",(0,r.jsx)(n.code,{children:"callback"})," passed to ",(0,r.jsx)(n.code,{children:"renderHook"}),". The ",(0,r.jsx)(n.code,{children:"Result"})," type is determined by the type passed to or inferred by the ",(0,r.jsx)(n.code,{children:"renderHook"})," call."]}),"\n",(0,r.jsx)(n.h3,{id:"rerender",children:(0,r.jsx)(n.code,{children:"rerender"})}),"\n",(0,r.jsxs)(n.p,{children:["A function to rerender the test component, causing any hooks to be recalculated. If ",(0,r.jsx)(n.code,{children:"newProps"})," are passed, they will replace the ",(0,r.jsx)(n.code,{children:"callback"})," function's ",(0,r.jsx)(n.code,{children:"initialProps"})," for subsequent rerenders. The ",(0,r.jsx)(n.code,{children:"Props"})," type is determined by the type passed to or inferred by the ",(0,r.jsx)(n.code,{children:"renderHook"})," call."]}),"\n",(0,r.jsx)(n.h3,{id:"unmount",children:(0,r.jsx)(n.code,{children:"unmount"})}),"\n",(0,r.jsxs)(n.p,{children:["A function to unmount the test component. This is commonly used to trigger cleanup effects for ",(0,r.jsx)(n.code,{children:"useEffect"})," hooks."]}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(n.p,{children:["Here we present some extra examples of using ",(0,r.jsx)(n.code,{children:"renderHook"})," API."]}),"\n",(0,r.jsxs)(n.h3,{id:"with-initialprops",children:["With ",(0,r.jsx)(n.code,{children:"initialProps"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const useCount = (initialCount: number) => {\n  const [count, setCount] = useState(initialCount);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  useEffect(() => {\n    setCount(initialCount);\n  }, [initialCount]);\n\n  return { count, increment };\n};\n\nit('should increment count', () => {\n  const { result, rerender } = renderHook((initialCount: number) => useCount(initialCount), {\n    initialProps: 1,\n  });\n\n  expect(result.current.count).toBe(1);\n\n  act(() => {\n    result.current.increment();\n  });\n\n  expect(result.current.count).toBe(2);\n  rerender(5);\n  expect(result.current.count).toBe(5);\n});\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"with-wrapper",children:["With ",(0,r.jsx)(n.code,{children:"wrapper"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"it('should use context value', () => {\n  function Wrapper({ children }: { children: ReactNode }) {\n    return <Context.Provider value=\"provided\">{children}</Context.Provider>;\n  }\n\n  const { result } = renderHook(() => useHook(), { wrapper: Wrapper });\n  // ...\n});\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>c});var r=t(7294);const o={},s=r.createContext(o);function c(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);